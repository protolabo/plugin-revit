{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projet IFT3150: D\u00e9veloppement d\u2019un plugin Revit pour l\u2019int\u00e9gration des donn\u00e9es Ekahau","text":"<p>Th\u00e8mes: G\u00e9nie logiciel, CAD, Int\u00e9gation logicielle Superviseur: Louis-Edouard Lafontant Collaborateurs: Bouthillette Parizeau (BPA)  </p>"},{"location":"#informations-importantes","title":"Informations importantes","text":"<p>Dates importantes</p> <ul> <li>Description du projet : 25 mai 2025  </li> <li>Pr\u00e9sentation et rapport : 8 ao\u00fbt 2025</li> </ul>"},{"location":"#equipe","title":"\u00c9quipe","text":"<ul> <li>Arman Nunez</li> <li>Erick Oswaldo de la Cruz Diaz</li> </ul>"},{"location":"#description-du-projet","title":"Description du projet","text":""},{"location":"#contexte","title":"Contexte","text":"<p>Dans le domaine de l\u2019ing\u00e9nierie, l\u2019utilisation d\u2019outils de mod\u00e9lisation tels que AutoCAD, Revit ou MATLAB est fr\u00e9quente. La conception d\u2019un projet d\u2019ing\u00e9nierie complet n\u00e9cessite souvent plusieurs outils sp\u00e9cialis\u00e9s. En t\u00e9l\u00e9communication, par exemple, Revit et Ekahau sont couramment utilis\u00e9s de mani\u00e8re compl\u00e9mentaire : Revit pour la conception architecturale, et Ekahau pour la simulation et le positionnement optimal des points d\u2019acc\u00e8s r\u00e9seau (Wi-Fi). Toutefois, l\u2019\u00e9change de donn\u00e9es entre ces deux logiciels demeure probl\u00e9matique en raison d\u2019un manque de compatibilit\u00e9 directe.</p>"},{"location":"#problematique-ou-motivations","title":"Probl\u00e9matique ou motivations","text":"<p>La simulation pour l\u2019analyse des r\u00e9seaux Wi-Fi dans Ekahau repr\u00e9sente une t\u00e2che particuli\u00e8rement longue et fastidieuse. En effet, cette op\u00e9ration n\u00e9cessite une intervention manuelle laborieuse et minutieuse, ce qui ralentit significativement le processus global de conception et d\u2019optimisation des infrastructures de communication. Actuellement, la seule assistance disponible consiste en l\u2019exportation d\u2019un plan 2D depuis Revit, qui sert de base pour la d\u00e9finition des \u00e9l\u00e9ments dans Ekahau.</p> <p>Cependant, cette m\u00e9thode reste insuffisante pour automatiser efficacement les nombreuses \u00e9tapes r\u00e9p\u00e9titives impliqu\u00e9es dans l\u2019int\u00e9gration des donn\u00e9es. L\u2019objectif de ce projet est donc de d\u00e9velopper un plugin capable d\u2019automatiser ces t\u00e2ches r\u00e9p\u00e9titives, sans n\u00e9cessiter d\u2019analyse approfondie par un op\u00e9rateur humain. Cette automatisation via code permettra d\u2019augmenter consid\u00e9rablement la productivit\u00e9 de l\u2019\u00e9quipe en charge du mod\u00e9lisation et de l\u2019analyse des r\u00e9seaux, tout en am\u00e9liorant la coh\u00e9rence et la qualit\u00e9 des r\u00e9sultats.</p>"},{"location":"#proposition-et-objectifs","title":"Proposition et objectifs","text":"<p>Pour contourner ce probl\u00e8me, il est propos\u00e9 de d\u00e9velopper un plugin int\u00e9gr\u00e9 au logiciel Revit permettant l\u2019exportation du mod\u00e8le au format de fichier Ekahau. Ce plugin offrira la possibilit\u00e9 de s\u00e9lectionner les plans du mod\u00e8le \u00e0 exporter, ainsi que de filtrer chaque \u00e9l\u00e9ment contenu dans celui-ci. Le fichier export\u00e9 contiendra, par cons\u00e9quent, tous les \u00e9l\u00e9ments n\u00e9cessaires \u00e0 la r\u00e9alisation de l\u2019analyse et de la simulation dans Ekahau, sans qu\u2019il soit n\u00e9cessaire de les d\u00e9finir manuellement.</p>"},{"location":"#echeancier","title":"\u00c9ch\u00e9ancier","text":"<p>Info</p> <p>Le suivi complet est disponible dans la page Suivi de projet.</p> Jalon (Milestone) Date pr\u00e9vue Livrable Statut Ouverture de projet 9 mai \u2705 Termin\u00e9 Prototype 1 23 mai Maquette + Flux d'activit\u00e9s \u2705 Termin\u00e9 Analyse des exigences 30 mai Rapport des exigences \ud83d\udd04 En cours Prototype 1 30 mai Exploration de l\u2019API de Revit \ud83d\udd04 En cours Mod\u00e8le de donne\u00e9s 6 juin Diagramme UML ou entit\u00e9-association \u2705 Termin\u00e9 Prototype 1 23 mai Exploration des fichiers Ekahau \ud83d\udd04 En cours Revue du prototype 11 juin Feedback encadrant + ajustements \u2705 Termin\u00e9 Prototype 2 4 juillet Prototype finale + Flux \u23f3 \u00c0 venir"},{"location":"analysis/","title":"\u00c9tudes pr\u00e9liminaires","text":""},{"location":"analysis/#analyse-du-probleme","title":"Analyse du probl\u00e8me","text":"<p>Revit est largement utilis\u00e9 dans le secteur de la construction, notamment par les architectes, les ing\u00e9nieurs et les designers d'int\u00e9rieur. L'Association professionnelle des designers d'int\u00e9rieur du Qu\u00e9bec (APDIQ) a d'ailleurs mis en place un programme de formation Revit en partenariat avec GRAITEC, soulignant l'importance de cet outil dans la transition num\u00e9rique du secteur. Cependant, il n\u2019existe aucun outil professionnel, qu\u2019il soit libre ou payant, permettant la communication entre le logiciel de conception Revit et le logiciel d\u2019analyse Ekahau. Un tel outil pourrait r\u00e9duire significativement le temps n\u00e9cessaire \u00e0 l\u2019analyse des r\u00e9seaux Wi-Fi dans un mod\u00e8le.</p>"},{"location":"analysis/#exigences","title":"Exigences","text":"<p>Le projet est divis\u00e9 en deux parties : \"Export vers Ekahau\" et \"Import depuis Ekahau\". La premi\u00e8re partie consiste \u00e0 g\u00e9n\u00e9rer un fichier compatible avec Ekahau \u00e0 partir d\u2019un mod\u00e8le Revit, afin de r\u00e9aliser une simulation de points d\u2019acc\u00e8s Wi-Fi. Selon l\u2019avancement de cette premi\u00e8re phase et le temps disponible, la deuxi\u00e8me partie sera abord\u00e9e. Celle-ci a pour objectif d\u2019importer les informations  des points d\u2019acc\u00e8s simul\u00e9s dans Ekahau vers le mod\u00e8le Revit original.</p>"},{"location":"analysis/#exigences-fonctionnelles-export-vers-ekahau","title":"Exigences fonctionnelles \u2013 Export vers Ekahau","text":"<ul> <li>\ud83d\udd04 Le fichier Ekahau doit contenir tous les murs, portes et fen\u00eatres du mod\u00e8le Revit, ou uniquement ceux situ\u00e9s \u00e0 l\u2019int\u00e9rieur de la zone d\u00e9limit\u00e9e par l\u2019utilisateur.</li> <li>\u23f3 Le plugin doit offrir \u00e0 l\u2019utilisateur la possibilit\u00e9 d\u2019exclure les escaliers de la simulation et d\u2019inclure les murs des ascenseurs, avec une option distincte pour chaque \u00e9tage du mod\u00e8le.</li> <li>\u23f3 Tous les \u00e9l\u00e9ments export\u00e9s vers Ekahau doivent comporter une valeur d\u2019att\u00e9nuation en dB, soit en les faisant correspondre \u00e0 un type d\u2019\u00e9l\u00e9ment existant dans Ekahau, soit en calculant manuellement leur att\u00e9nuation.</li> <li>\u23f3 Le fichier export\u00e9 doit respecter la hauteur des \u00e9tages, l\u2019\u00e9chelle du mod\u00e8le Revit et l\u2019\u00e9paisseur des planchers et des plafonds.</li> <li>\ud83d\udd04 Le fichier g\u00e9n\u00e9r\u00e9 doit contenir un b\u00e2timent structur\u00e9 par \u00e9tages, refl\u00e9tant fid\u00e8lement l\u2019organisation du mod\u00e8le Revit.</li> <li>\ud83d\udd04 Le plugin doit \u00eatre facile \u00e0 utiliser par des ing\u00e9nieurs ne poss\u00e9dant pas de connaissances approfondies en programmation.</li> <li>\ud83d\udd04 L\u2019exportation doit \u00eatre rapide, afin de ne pas perturber le travail quotidien des utilisateurs.</li> </ul>"},{"location":"analysis/#exigences-non-fonctionnelles-export-vers-ekahau","title":"Exigences non fonctionnelles \u2013 Export vers Ekahau","text":"<ul> <li>\u23f3 Automatiser le cadrage de la zone \u00e0 exporter depuis Revit.  </li> <li>\u2705 Mettre en place automatiquement l'\u00e9chelle dans Ekahau.</li> <li>\u23f3 Assurer la compatibilit\u00e9 avec .NET 8.0</li> <li>\u23f3 Garantir que tous les murs adjacents export\u00e9s dans le fichier Ekahau soient interconnect\u00e9s.</li> </ul>"},{"location":"analysis/#exigences-fonctionnelles-import-depuis-ekahau","title":"Exigences fonctionnelles \u2013 Import depuis Ekahau","text":"<ul> <li>\u23f3 Exporter depuis Ekahau vers Revit en respectant la position exacte des points d\u2019acc\u00e8s simul\u00e9s.  </li> </ul>"},{"location":"analysis/#exigences-non-fonctionnelles-import-depuis-ekahau","title":"Exigences non fonctionnelles \u2013 Import depuis Ekahau","text":"<ul> <li>\u23f3 Mod\u00e9liser les points d'acc\u00e8s import\u00e9s dans Revit sous une famille de symbole BPA.</li> </ul> <p>L\u00e9gende des symboles</p> <p>\u2705 Termin\u00e9, \ud83d\udd04 En cours, \u23f3 \u00c0 venir</p>"},{"location":"analysis/#recherche-de-solutions","title":"Recherche de solutions","text":"<ul> <li>\u00c0 l\u2019heure actuelle, il n\u2019existe aucune solution permettant l\u2019automatisation de la cr\u00e9ation de mod\u00e8les Ekahau \u00e0 partir de mod\u00e8les Revit, laissant comme seule option leur \u00e9laboration manuelle.</li> </ul>"},{"location":"conception/","title":"Conception","text":""},{"location":"conception/#architecture","title":"Architecture","text":"<ul> <li>D\u00e9crire l'architecture du syst\u00e8me propos\u00e9.</li> </ul>"},{"location":"conception/#choix-technologiques","title":"Choix technologiques","text":"<ul> <li>Justifier les technologies et outils choisis.</li> </ul>"},{"location":"conception/#modeles-et-diagrammes","title":"Mod\u00e8les et diagrammes","text":"<ul> <li>Inclure des diagrammes UML, maquettes, etc.</li> </ul>"},{"location":"docs/","title":"Documentation du projet","text":""},{"location":"docs/#installation","title":"Installation","text":"<p>1. Cr\u00e9er un dossier 'Create' dans le dossier 'repos' de Visual Studio Community.</p> <p>2. Copier le dossier 'Create' (repo) et le fichier 'Create.sln' \u00e0 l\u2019int\u00e9rieur du dossier 'Create' (local).</p> <p>3.</p> <p>Le dossier <code>packages/</code> n\u2019est pas inclus dans le repo. Les d\u00e9pendances doivent \u00eatre restaur\u00e9es.</p>"},{"location":"docs/#avec-visual-studio-community","title":"Avec Visual Studio Community","text":"<ul> <li>Ouvrir le fichier <code>.sln</code> dans Visual Studio. Visual Studio d\u00e9tectera les packages manquants et les restaurera automatiquement.</li> <li> <p>Si les packages ne se restaurent pas automatiquement :</p> <ul> <li>Aller dans :     <pre><code>Outils \u2192 Gestionnaire de packages NuGet \u2192 Console du gestionnaire de packages\n</code></pre></li> <li> <p>Ex\u00e9cuter :</p> <pre><code>Update-Package -reinstall\n</code></pre> <p>ou :</p> <pre><code>nuget restore\n</code></pre> </li> <li> <p>Compiler ensuite le projet avec <code>Ctrl + Maj + B</code>.</p> </li> </ul> </li> </ul> <p>4. Copier le fichier 'Create.addin' dans le dossier 'Addins\\&lt;<code>version</code>&gt;' de Revit.</p> <p>5. Mettre \u00e0 jour la ligne :   <pre><code>&lt;Assembly&gt;C:\\Users\\pelon\\source\\repos\\Create\\Create\\bin\\Debug\\Create.dll&lt;/Assembly&gt;\n</code></pre></p> <p>du fichier 'Create.addin' pour qu\u2019elle pointe vers le fichier 'Create.dll' situ\u00e9 dans 'Create\\bin\\Debug'.</p> <p>Copier le contenu du dossier src\\tools (repo) dans 'Create\\bin\\Debug'.</p>"},{"location":"docs/#usage","title":"Usage","text":"<ul> <li> <p>Deux vid\u00e9os d\u00e9monstratives se trouvent dans le dossier partag\u00e9 du projet sur Google Docs.</p> </li> <li> <p>Vid\u00e9o de d\u00e9monstration sur YouTube (partie Revit uniquement) https://www.youtube.com/watch?v=ZQKJaEJjRiY</p> </li> </ul>"},{"location":"docs/#development","title":"Development","text":""},{"location":"docs/#description-des-fichiers-ekahau","title":"Description des fichiers Ekahau","text":"<p>Un fichier Ekahau est une archive ZIP avec l\u2019extension .esx. Ce fichier compress\u00e9 contient les fichiers suivants :     <pre><code>applicationProfiles.json\nattenuationAreaTypes.json\nbuildingFloors.json\nbuildings.json\ndeviceProfiles.json\nfloorPlans.json\nfloorTypes.json\nimages.json\nnetworkCapacitySettings.json\nproject.json\nprojectConfiguration.json\nprojectHistory.json\nrequirements.json\nusageProfiles.json\nwallPoints.json\nwallSegments.json\nwallTypes.json\n</code></pre></p> <p>Comme ces informations sont publiques, seuls les fichiers consult\u00e9s ou modifi\u00e9s par le code seront expliqu\u00e9s,  et seules les parties pertinentes de chaque fichier seront montr\u00e9es.</p>"},{"location":"docs/#applicationprofilesjson","title":"applicationProfiles.json","text":"<p>Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#attenuationareatypesjson","title":"attenuationAreaTypes.json","text":"<p>Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#buildingfloorsjson","title":"buildingFloors.json","text":"<p>Ekahau permet de cr\u00e9er un b\u00e2timent en utilisant les diff\u00e9rents \u00e9tages (views) du mod\u00e8le Revit, ce qui permet de simuler la propagation  d\u2019internet depuis les points d\u2019acc\u00e8s \u00e0 travers les diff\u00e9rents \u00e9tages.</p> <p>Ce fichier contient les informations n\u00e9cessaires pour repr\u00e9senter chaque niveau du b\u00e2timent. Ce fichier est constitu\u00e9 d\u2019une liste de \u00e9tages (floors) ; ci-dessous se trouve un exemple d\u2019une telle instance de la liste.</p> <pre><code>  {\n    \"floorPlanId\": \"3f5f840b-3173-4bee-a2e0-e9003e74318b\",\n    \"buildingId\": \"f4a0687e-7203-45ca-9e02-0f0b9538250a\",\n    \"floorTypeId\": \"1b3ed0d7-4bb9-47c4-b3f1-993ba66ad628\",\n    \"floorNumber\": 2,\n    \"height\": 2.5,\n    \"thickness\": 0.5,\n    \"id\": \"3d5bd4cf-2e87-46f2-906d-729ca9c90eeb\",\n    \"status\": \"CREATED\"\n  }\n</code></pre>"},{"location":"docs/#buildingsjson","title":"buildings.json","text":"<p>Contient la liste des b\u00e2timents (dans notre cas, il y en aura toujours un seul).</p>"},{"location":"docs/#deviceprofilesjson","title":"deviceProfiles.json","text":"<p>Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#floorplansjson","title":"floorPlans.json","text":"<p>Chaque vue dans le mod\u00e8le Revit est repr\u00e9sent\u00e9e par un \u00e9tage dans Ekahau. Ce fichier contient les informations de chaque \u00e9tage, y compris l\u2019image de fond correspondante. Ce fichier est constitu\u00e9 d\u2019une liste de \u00e9tages (views) ; ci-dessous se trouve un exemple d\u2019une telle instance de la liste.</p> <pre><code>  {\n    \"name\": \"exported_view - Floor Plan - Level 1.bmp\",\n    \"width\": 1500.0,\n    \"height\": 1267.0,\n    \"metersPerUnit\": 0.02683082676480316,\n    \"imageId\": \"294e9d7c-18d4-4345-b29e-75208499a2da\",\n    \"gpsReferencePoints\": [],\n    \"floorPlanType\": \"FSPL\",\n    \"cropMinX\": 0.0,\n    \"cropMinY\": 0.0,\n    \"cropMaxX\": 1500.0,\n    \"cropMaxY\": 1267.0,\n    \"rotateUpDirection\": \"UP\",\n    \"tags\": [],\n    \"id\": \"51213b74-6cd4-496d-8669-155f9f02607c\",\n    \"status\": \"CREATED\"\n  }\n</code></pre>"},{"location":"docs/#floortypesjson","title":"floorTypes.json","text":"<p>Ce fichier contient les caract\u00e9ristiques de propagation du signal pour diff\u00e9rents types de planchers que l\u2019on trouve dans des b\u00e2timents courants tels que des bureaux,  des h\u00f4tels, etc. Comme le type de plancher varie selon chaque mod\u00e8le Revit, le code en s\u00e9lectionne un par d\u00e9faut, et l\u2019utilisateur doit choisir le type de plancher  correct une fois que le fichier est ouvert avec Ekahau.</p>"},{"location":"docs/#imagesjson","title":"images.json","text":"<p>Ekahau enregistre un fichier contenant la liste des images qui seront utilis\u00e9es dans le mod\u00e8le comme fonds. Ce fichier contient cette liste ; le champ \u00ab id \u00bb fait r\u00e9f\u00e9rence au nom de l\u2019image, donc le nom du fichier image est : image-&lt;id&gt;. Ce fichier est constitu\u00e9 d\u2019une liste de images ; ci-dessous se trouve un exemple d\u2019une telle instance de la liste.   <pre><code>  {\n  \"imageFormat\": \"BMP\",\n  \"resolutionWidth\": 1500.0,\n  \"resolutionHeight\": 1400.0,\n  \"id\": \"e3657068-273e-4836-8ea7-bad33db464f5\",\n  \"status\": \"CREATED\"\n  }\n</code></pre></p>"},{"location":"docs/#networkcapacitysettingsjson","title":"networkCapacitySettings.json","text":"<p>Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#projectjson","title":"project.json","text":"<p>Contient les informations g\u00e9n\u00e9rales du fichier : name, version, date de cr\u00e9ation, date de modification, etc. La date de cr\u00e9ation est ajout\u00e9e manuellement au moment de la cr\u00e9ation du fichier \u00e0 l\u2019aide du plugin.</p>"},{"location":"docs/#projectconfigurationjson","title":"projectConfiguration.json","text":"<p>Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#projecthistoryjson","title":"projectHistory.json","text":"<p>Ce fichier contient l\u2019historique des modifications apport\u00e9es au mod\u00e8le. Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#requirementsjson","title":"requirements.json","text":"<p>Ce fichier contient l\u2019ensemble des normes techniques des r\u00e9seaux locaux (LAN) et sp\u00e9cifie l\u2019ensemble des protocoles de contr\u00f4le d\u2019acc\u00e8s au m\u00e9dia (MAC)  et de la couche physique (PHY) pour la mise en \u0153uvre de la communication informatique sans fil (WLAN) sur chaque \u00e9tage,  en fonction du profil s\u00e9lectionn\u00e9. Exemple IEEE802_11. Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#usageprofilesjson","title":"usageProfiles.json","text":"<p>Ce fichier n\u2019est ni modifi\u00e9 ni consult\u00e9 par le code.</p>"},{"location":"docs/#wallpointsjson","title":"wallPoints.json","text":"<p>Ce fichier contient la liste de tous les points correspondant au d\u00e9but et \u00e0 la fin de tous les \u00e9l\u00e9ments de la simulation (murs, portes, fen\u00eatres, etc.),  pour chaque \u00e9tage. Ce fichier est constitu\u00e9 d\u2019une liste de wallPoints ; ci-dessous se trouve un exemple d\u2019une telle instance de la liste.   <pre><code>  {\n    \"location\": {\n      \"floorPlanId\": \"51213b74-6cd4-496d-8669-155f9f02607c\",\n      \"coord\": { \"x\": 841.31512950818, \"y\": 573.585663952959 }\n    },\n    \"id\": \"9209f1a2-c61f-46fa-b9f7-8581fd97dd02\",\n    \"status\": \"CREATED\"\n  }\n</code></pre></p>"},{"location":"docs/#wallsegmentsjson","title":"wallSegments.json","text":"<p>Ce fichier contient une liste de segments reliant deux points pour former les \u00e9l\u00e9ments de la simulation (murs, portes, fen\u00eatres, etc.). Ce fichier est constitu\u00e9 d\u2019une liste de wallSegments ; ci-dessous se trouve un exemple d\u2019une telle instance de la liste.   <pre><code>  {\n    \"wallPoints\": [\"9209f1a2-c61f-46fa-b9f7-8581fd97dd02\", \"8c76e652-0717-4fc1-bdd7-f51de423d4d5\"],\n    \"wallTypeId\": \"e2713a0a-d747-45b1-8b5f-efa334b32348\",\n    \"originType\": \"WALL_TOOL\",\n    \"id\": \"ada4bd7b-d3be-42bd-8ce8-c4bbb715a9c6\",\n    \"status\": \"CREATED\"\n  },\n</code></pre></p>"},{"location":"docs/#walltypesjson","title":"wallTypes.json","text":"<p>Ce fichier contient les informations pour chaque type de mur, comme son facteur d\u2019att\u00e9nuation et son \u00e9paisseur. Pour trouver le facteur d\u2019att\u00e9nuation affich\u00e9 dans Ekahau, il est n\u00e9cessaire de multiplier le facteur d\u2019att\u00e9nuation par l\u2019\u00e9paisseur du mur. Ce fichier est constitu\u00e9 d\u2019une liste de murs ; ci-dessous se trouve un exemple d\u2019une telle instance de la liste.   <pre><code>  {\n    \"name\": \"Window, Thick\",\n    \"key\": \"ThickWindow\",\n    \"color\": \"#ADE1FF\",\n    \"propagationProperties\": [\n      {\n        \"band\": \"SIX\",\n        \"attenuationFactor\": 200.0,\n        \"reflectionCoefficient\": 0.6944,\n        \"diffractionCoefficient\": 11.0\n      },\n      {\n        \"band\": \"TWO\",\n        \"attenuationFactor\": 200.0,\n        \"reflectionCoefficient\": 0.6944,\n        \"diffractionCoefficient\": 11.0\n      },\n      {\n        \"band\": \"FIVE\",\n        \"attenuationFactor\": 200.0,\n        \"reflectionCoefficient\": 0.6944,\n        \"diffractionCoefficient\": 11.0\n      }\n    ],\n    \"thickness\": 0.015,\n    \"lowerEdge\": 0.0,\n    \"keybindNumber\": 9,\n    \"id\": \"9624a855-0f43-45eb-abc1-3998111c54f9\",\n    \"status\": \"CREATED\"\n  },\n</code></pre></p>"},{"location":"docs/#systemes-de-coordonnees-revit-et-ekahau","title":"Syst\u00e8mes de coordonn\u00e9es Revit et Ekahau","text":""},{"location":"docs/#conversion-des-coordonnees-de-revit-vers-ekahau","title":"Conversion des coordonn\u00e9es de Revit vers Ekahau","text":"<p>Pour convertir les coordonn\u00e9es de Revit en coordonn\u00e9es utilisables dans Ekahau, deux \u00e9l\u00e9ments essentiels doivent \u00eatre pris en compte :</p> <ul> <li>Revit utilise un syst\u00e8me de coordonn\u00e9es absolu en pieds.</li> <li>Ekahau utilise un syst\u00e8me de coordonn\u00e9es absolu en pixels.</li> </ul>"},{"location":"docs/#exemple-illustre","title":"Exemple illustr\u00e9","text":"<p>Dans l'image ci-dessus :</p> <ul> <li>\u00c0 gauche, nous avons une vue hypoth\u00e9tique de Revit. Le syst\u00e8me de coordonn\u00e9es absolu y est repr\u00e9sent\u00e9 par les fl\u00e8ches verte (axe Y) et rouge (axe X), ainsi qu\u2019un Crop Region (r\u00e9gion de d\u00e9coupe). \u00c9tant donn\u00e9 que l'origine est absolue et commune \u00e0 toutes les vues, le centre de la r\u00e9gion de d\u00e9coupe ne co\u00efncide pas n\u00e9cessairement avec l\u2019origine du syst\u00e8me de coordonn\u00e9es.</li> <li>\u00c0 droite, nous voyons une image (Map) dans Ekahau. Remarquez que l'origine de la carte se trouve dans le coin sup\u00e9rieur gauche, ce qui signifie qu\u2019il n\u2019existe pas de coordonn\u00e9es n\u00e9gatives dans Ekahau.</li> </ul> <p>La taille de l\u2019image d\u00e9pend de la taille d\u00e9finie par l\u2019utilisateur dans Revit. Pour cet exemple, nous avons export\u00e9 une image de 1500 x 1350 pixels, afin de respecter les proportions de la vue dans Revit.</p>"},{"location":"docs/#calcul-dun-point","title":"Calcul d\u2019un point","text":"<p>Dans cet exemple, nous avons plac\u00e9 un point dans Revit \u00e0 la position (-2, -3).</p> <ul> <li>La largeur totale de la r\u00e9gion de d\u00e9coupe est de 10 pieds.</li> <li>La hauteur totale est de 9 pieds.</li> </ul> <p>Pour convertir cette position vers Ekahau, il faut calculer la proportion du point par rapport \u00e0 la taille de la Crop Region, en partant de la position de l\u2019origine de l\u2019image Ekahau (coin sup\u00e9rieur gauche).</p>"},{"location":"docs/#calcul-des-proportions","title":"Calcul des proportions","text":"<ul> <li>Pour X : entre -6 et -2, il y a 4 pieds \u2192 4 / 10 = 0,4 (soit 40 %)</li> <li>Pour Y : entre 3 et -3, il y a 6 pieds \u2192 6 / 9 = 2/3</li> </ul>"},{"location":"docs/#conversion-en-pixels","title":"Conversion en pixels","text":"<ul> <li>Pour X : 0,4 \u00d7 1500 = 600 pixels</li> <li>Pour Y : (2/3) \u00d7 1350 = 900 pixels</li> </ul>"},{"location":"docs/#conclusion","title":"Conclusion","text":"<p>La position du point (-2, -3) dans Revit correspond \u00e0 la position (600, 900) dans Ekahau.</p>"},{"location":"docs/#correspondance-dechelle-revit-ekahau","title":"Correspondance d\u2019\u00e9chelle Revit - Ekahau","text":""},{"location":"docs/#definir-lechelle-dans-ekahau","title":"D\u00e9finir l\u2019\u00e9chelle dans Ekahau","text":"<p>Pour d\u00e9finir l\u2019\u00e9chelle dans Ekahau, il suffit d\u2019ajouter une ligne <code>\"metersPerUnit\"</code> avec la valeur appropri\u00e9e pour chaque \u00e9tage dans le fichier <code>floorPlans.json</code>.</p> <p>Cette valeur se calcule en divisant la taille r\u00e9elle (en m\u00e8tres) d\u2019un \u00e9l\u00e9ment connu \u2014 comme un mur, une porte ou une fen\u00eatre \u2014 par sa longueur en pixels sur l\u2019image.</p>"},{"location":"docs/#exemple","title":"Exemple","text":"<p>Prenons l\u2019exemple pr\u00e9c\u00e9dent : supposons qu\u2019il y ait un mur qui va du point (-2, -3) jusqu\u2019\u00e0 l\u2019origine absolue (0, 0).</p> <ul> <li>La position du point (-2, -3) dans Ekahau est (600, 900) pixels.</li> <li>L\u2019origine (0, 0) correspond \u00e0 (900, 450) pixels.</li> </ul>"},{"location":"docs/#1-longueur-reelle-du-mur-en-pieds","title":"1. Longueur r\u00e9elle du mur en pieds","text":"<p>On utilise le th\u00e9or\u00e8me de Pythagore :</p> <p>Longueur = \u221a[(-2)\u00b2 + (-3)\u00b2] Longueur = \u221a(4 + 9) = \u221a13 \u2248 3,6056 pieds</p> <p>Converti en m\u00e8tres : 3,6056 \u00d7 0,3048 \u2248 1,0998 m\u00e8tres</p>"},{"location":"docs/#2-longueur-du-mur-en-pixels","title":"2. Longueur du mur en pixels","text":"<p>Longueur = \u221a[(900 - 600)\u00b2 + (900 - 450)\u00b2] Longueur = \u221a(300\u00b2 + 450\u00b2) = \u221a(202500 + 90000) Longueur \u2248 540,83 pixels</p>"},{"location":"docs/#3-calcul-de-lechelle","title":"3. Calcul de l\u2019\u00e9chelle","text":"<p>metersPerUnit = 1,0998 / 540,83 \u2248 0,002033</p>"},{"location":"docs/#conclusion_1","title":"Conclusion","text":"<p>Dans cet exemple, la valeur \u00e0 ins\u00e9rer dans <code>floorPlans.json</code> serait :</p> <pre><code>\"metersPerUnit\": 0.002033\n</code></pre> <p> </p>"},{"location":"docs/#division-des-murs-en-segments","title":"Division des murs en segments","text":""},{"location":"docs/#division-des-murs","title":"Division des murs","text":"<p>Supposons que nous ayons un mur avec deux fen\u00eatres, comme illustr\u00e9 sur l\u2019image: </p> <p></p> <p>Par cons\u00e9quent, si l\u2019on trace le mur et les fen\u00eatres de cette mani\u00e8re, la section du mur correspondant aux fen\u00eatres contiendra \u00e0 la fois  le mat\u00e9riau du vitrage de la fen\u00eatre et celui du mur, et l\u2019analyse de la propagation du signal Internet lors de la simulation dans Ekahau  donnera des r\u00e9sultats impr\u00e9cis.</p> <p></p> <p>Pour cette raison, il est n\u00e9cessaire de diviser le mur en sections, comme illustr\u00e9 sur la figure.</p> <p></p> <p>Pour cela, nous utiliserons une fonction r\u00e9cursive qui divise le mur en segments en respectant les limites des ouvertures int\u00e9gr\u00e9es dans le mur.  Pour comprendre le fonctionnement de cette fonction, nous analyserons le mur pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment. L\u2019algorithme de la fonction, ainsi que les  param\u00e8tres qu\u2019elle re\u00e7oit, seront simplifi\u00e9s pour une meilleure compr\u00e9hension.</p> <ul> <li> <p>La fonction re\u00e7oit un mur accompagn\u00e9 de la liste des ouvertures qu\u2019il contient. Le mur est d\u00e9fini par ses points de d\u00e9part et d\u2019arriv\u00e9e,  et chaque ouverture est d\u00e9finie par ses points de d\u00e9part, interm\u00e9diaire et d\u2019arriv\u00e9e.</p> </li> <li> <p>La fonction prend la premi\u00e8re ouverture de la liste et divise le mur en deux segments : l\u2019un allant d\u2019une extr\u00e9mit\u00e9 du mur \u00e0 une  extr\u00e9mit\u00e9 de l\u2019ouverture, et l\u2019autre allant de l\u2019autre extr\u00e9mit\u00e9 du mur \u00e0 l\u2019autre extr\u00e9mit\u00e9 de l\u2019ouverture. Pour le moment, il n\u2019est pas important  que les ouvertures soient ordonn\u00e9es. Pour cet exemple, nous supposerons que la premi\u00e8re ouverture de la liste est en r\u00e9alit\u00e9 la deuxi\u00e8me ouverture  de gauche \u00e0 droite. Pour diviser correctement le mur en deux segments, il est n\u00e9cessaire de d\u00e9terminer quelle extr\u00e9mit\u00e9 du mur est la plus proche  de chaque extr\u00e9mit\u00e9 de l\u2019ouverture, comme illustr\u00e9 sur la figure :</p> </li> </ul> <p> </p> <p>Ce fragment de code permet de s\u2019assurer que le mur est segment\u00e9 correctement: <pre><code>  double openStart = axis == \"x\" ? opening.start_point.x : opening.start_point.y;\n  double openEnd = axis == \"x\" ? opening.end_point.x : opening.end_point.y;\n  double startVal = axis == \"x\" ? wall.start.x : wall.start.y;\n  double endVal = axis == \"x\" ? wall.end.x : wall.end.y;\n\n  double distStart = Math.Min(Math.Abs(startVal - openStart), Math.Abs(startVal - openEnd));\n  double distEnd = Math.Min(Math.Abs(endVal - openStart), Math.Abs(endVal - openEnd));\n\n  WallData wall1, wall2;\n\n  // Determines whether the opening is closer to the start or the end of the wall.\n  if (distStart &lt; distEnd)\n  {\n      // Split wall in segments according to the opening\n      double cut = Math.Abs(startVal - openStart) &lt; Math.Abs(startVal - openEnd) ? openStart : openEnd;\n\n      // code continues...\n</code></pre></p> <ul> <li> <p>Apr\u00e8s avoir divis\u00e9 le mur, le code supprime l\u2019ouverture de la liste des ouvertures. Pour chaque segment du mur,  le code cr\u00e9e une nouvelle liste d\u2019ouvertures et d\u00e9termine quelles ouvertures correspondent \u00e0 quel segment du mur. Ensuite, elle appelle la fonction r\u00e9cursivement avec chaque segment de mur cr\u00e9\u00e9 et sa liste correspondante.</p> </li> <li> <p>Le segment de droite ne contient aucune ouverture, tandis que le segment de gauche en contient une. Par cons\u00e9quent,  le segment de droite correspond au cas de base de la fonction r\u00e9cursive et s\u2019arr\u00eate, en ajoutant ce segment \u00e0 la liste  des r\u00e9sultats, tandis que le segment de gauche doit \u00e0 nouveau diviser le mur.</p> </li> </ul> <p></p> <ul> <li>Le mur est de nouveau divis\u00e9 en deux segments, et une nouvelle liste d\u2019ouvertures est cr\u00e9\u00e9e pour chaque segment.  \u00c9tant donn\u00e9 qu\u2019il ne reste plus d\u2019ouvertures, les deux listes seront vides et les deux segments correspondront au  cas de base lors de l\u2019appel r\u00e9cursif de la fonction. Par cons\u00e9quent, les deux segments sont ajout\u00e9s \u00e0 la liste des  r\u00e9sultats et l\u2019ex\u00e9cution de la fonction r\u00e9cursive se termine. On obtient ainsi le mur compl\u00e8tement segment\u00e9.</li> </ul> <p></p>"},{"location":"docs/#tri-des-ouvertures","title":"Tri des ouvertures","text":"<p>Pour faciliter l\u2019interconnexion des segments, nous devons trier les murs de mani\u00e8re ascendante, ainsi que leurs points de d\u00e9part et d\u2019arriv\u00e9e.  Supposons que le mur pr\u00e9c\u00e9dent ne contienne pas deux fen\u00eatres, mais une fen\u00eatre et un \u201cvide\u201d que le concepteur a ins\u00e9r\u00e9 pour que le propri\u00e9taire  de la maison puisse y placer un \u00e9lectrom\u00e9nager. La repr\u00e9sentation graphique serait alors la suivante :</p> <p></p> <p>\u00c9tant donn\u00e9 que les listes de murs et d\u2019ouvertures ne conservent pas de relation directe avec le mod\u00e8le graphique, il est possible que la  liste des ouvertures du mur ressemble \u00e0 ceci :</p> <p><pre><code>    \"openings\" : [\n      {\n          \"type\" : \"wall\",\n          \"start_point\" : 4,\n          \"end_point\" : 6\n      },\n      {\n          \"type\" : \"void\",\n          \"start_point\" : 6,\n          \"end_point\" : 8\n      },\n      {\n          \"type\" : \"window\",\n          \"start_point\" : 4,\n          \"end_point\" : 2\n      },\n        {\n          \"type\" : \"wall\",\n          \"start_point\" : 0,\n          \"end_point\" : 2\n      },\n        {\n          \"type\" : \"wall\",\n          \"start_point\" : 10,\n          \"end_point\" : 8\n      }\n    ]\n</code></pre> Apr\u00e8s avoir divis\u00e9 le mur en segments, le code s\u2019assure que les ouvertures ainsi que leurs points de d\u00e9part et d\u2019arriv\u00e9e sont stock\u00e9s dans le bon ordre.</p> <pre><code>    \"openings\" : [\n      {\n          \"type\" : \"wall\",\n          \"start_point\" : 0,\n          \"end_point\" : 2\n      },\n      {\n          \"type\" : \"window\",\n          \"start_point\" : 2,\n          \"end_point\" : 4\n      },\n      {\n          \"type\" : \"wall\",\n          \"start_point\" : 4,\n          \"end_point\" : 6\n      },\n      {\n          \"type\" : \"void\",\n          \"start_point\" : 6,\n          \"end_point\" : 8\n      },\n      {\n          \"type\" : \"wall\",\n          \"start_point\" : 8,\n          \"end_point\" : 10\n      }\n    ]\n</code></pre>"},{"location":"docs/#interconnexion-entre-murs-et-segments","title":"Interconnexion entre murs et segments","text":"<p>L\u2019interconnexion des murs et de leurs segments se fait en deux \u00e9tapes.</p>"},{"location":"docs/#interconnexion-entre-segments","title":"Interconnexion entre segments","text":"<p>Pour commencer, analysons comment connecter les diff\u00e9rents segments de mur entre eux. </p> <p>Pour cr\u00e9er un mur dans Ekahau, il est n\u00e9cessaire d\u2019ajouter deux points dans le fichier wallPoints.json avec leurs ID respectifs,  puis de cr\u00e9er un segment dans le fichier wallSegments.json en faisant r\u00e9f\u00e9rence aux ID de ces points.</p> <p>Pour cette \u00e9tape, le premier segment n\u2019est pas pris en compte car ce segment contient le point initial du mur, qui sera utilis\u00e9 ult\u00e9rieurement  pour tenter de connecter le mur avec d\u2019autres murs du mod\u00e8le. Supposons que le premier segment ait d\u00e9j\u00e0 \u00e9t\u00e9 plac\u00e9,  c\u2019est-\u00e0-dire que ses points initial et final sont d\u00e9j\u00e0 enregistr\u00e9s dans le fichier correspondant.</p> <p>Pour le mur de l\u2019exemple, on constate que le point final du premier segment est suffisamment proche du point initial du second segment  (en fait, ils sont au m\u00eame point). Donc, au lieu de cr\u00e9er un nouveau point initial pour le second segment, on prend simplement l\u2019ID  correspondant au point final du premier segment, on cr\u00e9e un nouveau point correspondant au point final du second segment, puis on cr\u00e9e le segment.  Ainsi, pour tracer les deux segments, seuls trois points sont n\u00e9cessaires, et les murs seront interconnect\u00e9s.</p> <p>Ce processus se r\u00e9p\u00e8te successivement jusqu\u2019\u00e0 la fin de la liste des segments.</p> <p>\u00c9tant donn\u00e9 que les vides ne sont pas trac\u00e9s, la distance entre le point final du troisi\u00e8me segment et le point initial du  cinqui\u00e8me (puisque le vide correspond au quatri\u00e8me segment) ne permet pas de r\u00e9aliser l\u2019interconnexion entre les segments.  Par cons\u00e9quent, pour le cinqui\u00e8me segment, il est n\u00e9cessaire de cr\u00e9er les points initial et final dans le fichier JSON correspondant.</p>"},{"location":"docs/#interconnexion-entre-murs","title":"Interconnexion entre murs","text":"<p>Pour r\u00e9aliser la connexion entre murs, on utilise une liste auxiliaire qui contient les points initial et final de tous les murs trac\u00e9s.  Ces points correspondent au point initial du premier segment et au point final du dernier segment. Cette liste contient les coordonn\u00e9es  du point ainsi que son ID correspondant</p> <p>Pour r\u00e9aliser l\u2019interconnexion entre murs, il existe deux cas.</p> <ul> <li>Le mur ne contient qu\u2019un seul segment.</li> </ul> <p>Si le mur ne contient qu\u2019un seul segment, cela signifie qu\u2019il n\u2019a pas d\u2019ouvertures. Dans ce cas, les points initial et final du  segment correspondent aux points initial et final du mur. Pour ce type de murs, on recherche dans la liste auxiliaire s\u2019il existe  un point proche de chaque extr\u00e9mit\u00e9 permettant de r\u00e9aliser la connexion. S\u2019il n\u2019existe pas de point suffisamment proche pour l\u2019un  des points d\u2019extr\u00e9mit\u00e9, un nouveau point est cr\u00e9\u00e9 dans le fichier JSON et ce point est ajout\u00e9 \u00e0 la liste auxiliaire.</p> <ul> <li>Le mur contient plus d\u2019une ouverture</li> </ul> <p>Si le mur contient plus d\u2019un segment, alors le point initial du premier segment correspond au point initial du mur. Par cons\u00e9quent,  une recherche est effectu\u00e9e dans la liste auxiliaire pour v\u00e9rifier s\u2019il existe un point suffisamment proche permettant de r\u00e9aliser la connexion.  S\u2019il n\u2019y a pas de point suffisamment proche, un nouveau point est cr\u00e9\u00e9 dans le fichier JSON et ce point est ajout\u00e9 \u00e0 la liste auxiliaire.</p> <p>D\u2019autre part, nous savons que le point final du dernier segment correspond au point final du mur. Par cons\u00e9quent, une recherche est  effectu\u00e9e dans la liste auxiliaire pour v\u00e9rifier s\u2019il existe un point suffisamment proche pour cr\u00e9er la connexion. En cas de point trouv\u00e9,  le dernier segment du fichier JSON est supprim\u00e9 (car ce segment est cr\u00e9\u00e9 ailleurs dans le code) et un nouveau segment est cr\u00e9\u00e9 en utilisant  le point trouv\u00e9 \u00e0 la place du point final du dernier segment. Si aucun point suffisamment proche n\u2019est trouv\u00e9 dans la liste auxiliaire,  aucune action n\u2019est r\u00e9alis\u00e9e, car le dernier segment de tout mur est toujours trac\u00e9.</p>"},{"location":"docs/#description-des-classes","title":"Description des classes","text":""},{"location":"docs/#attenuationupdater","title":"AttenuationUpdater","text":"<p>La classe AttenuationUpdater prend les valeurs d'att\u00e9nuation saisies par l'utilisateur pour chaque mur dans Ekahau et les met \u00e0 jour dans le fichier  JSON Ekahau correspondant.</p>"},{"location":"docs/#updateekahauvalues","title":"UpdateEkahauValues()","text":"<ul> <li>Param\u00e8tres: null</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode UpdateEkahauValues() prend les valeurs d\u2019att\u00e9nuation saisies par l\u2019utilisateur, qui ont \u00e9t\u00e9 enregistr\u00e9es dans le fichier JSON wall_data, et met \u00e0 jour  les valeurs d\u2019att\u00e9nuation dans le fichier wallTypes.json d'Ekahau, en respectant les valeurs d\u2019att\u00e9nuation selon l\u2019\u00e9paisseur du mur.</p>"},{"location":"docs/#buildingfloorcreator","title":"BuildingFloorCreator","text":"<p>La classe BuildingFloorCreator cr\u00e9e le fichier buildingFloors.json d'Ekahau pour cr\u00e9er un \u00e9tage pour chaque vue (View) du mod\u00e8le Revit  \u00e0 l\u2019int\u00e9rieur du b\u00e2timent Ekahau.</p>"},{"location":"docs/#createbuildingfloorsjsonfilesstring-destdir","title":"CreateBuildingFloorsJsonFiles(string destDir)","text":"<ul> <li>Param\u00e8tres: (string) le chemin du fichier de sortie</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode CreateBuildingFloorsJsonFiles(string destDir) extrait les informations correspondantes \u00e0 partir des fichiers Ekahau  floorPlans.json, buildings.json, et floorTypes.json et cr\u00e9e ensuite le fichier buildingFloors.json, en g\u00e9n\u00e9rant un \u00e9tage pour chaque vue (View)  du mod\u00e8le Revit, en ajoutant les r\u00e9f\u00e9rences n\u00e9cessaires pour associer chaque \u00e9tage au bon type de plancher et au bon b\u00e2timent,  tout en respectant le format requis par Ekahau</p>"},{"location":"docs/#ekahaubuildingcreator","title":"EkahauBuildingCreator","text":"<p>La classe EkahauBuildingCreator cr\u00e9e un b\u00e2timent dans Ekahau.</p>"},{"location":"docs/#createbuildingfloorsjsonfilesstring-destdir_1","title":"CreateBuildingFloorsJsonFiles(string destDir)","text":"<ul> <li>Param\u00e8tres: (string) le chemin du fichier de sortie</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode CreateBuildingFloorsJsonFiles(string destDir) cr\u00e9e le fichier buildings.json, qui contient les informations et la structure  requises par Ekahau pour repr\u00e9senter l\u2019unique b\u00e2timent qui sera utilis\u00e9 pour le mod\u00e8le.</p>"},{"location":"docs/#ekahaufilecreator","title":"EkahauFileCreator","text":"<p>La classe EkahauFileCreator prend les fichiers JSON pr\u00e9par\u00e9s au pr\u00e9alable et cr\u00e9e le fichier final d'Ekahau.</p>"},{"location":"docs/#createesxfilestring-chosenfilename","title":"CreateEsxFile(string chosenFileName)","text":"<ul> <li>Param\u00e8tres: (string) le nom du fichier final</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode CreateEsxFile(string chosenFileName) prend le dossier Template contenant tous les fichiers JSON qui composent le fichier Ekahau, le compresse et lui donne  le nom correspondant avec l\u2019extension .esx.</p>"},{"location":"docs/#filetemplatecreator","title":"FileTemplateCreator","text":"<p>La classe FileTemplateCreator permet de s\u00e9lectionner le nom et l\u2019emplacement du fichier final Ekahau et cr\u00e9e un dossier avec  les fichiers de base n\u00e9cessaires \u00e0 la cr\u00e9ation du fichier Ekahau.</p>"},{"location":"docs/#createfiletemplateref-string-chosenfilename-string-destdir","title":"CreateFileTemplate(ref string chosenFileName, string destDir)","text":"<ul> <li>Param\u00e8tres: (string) le nom du fichier final Ekahau pass\u00e9 par r\u00e9f\u00e9rence, (string) le chemin du dossier qui contiendra les fichiers JSON</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode CreateFileTemplate(ref string chosenFileName, string destDir) affiche une bo\u00eete de dialogue permettant \u00e0 l\u2019utilisateur de choisir le nom  et l\u2019emplacement du fichier final Ekahau, puis copie un dossier contenant les fichiers de base n\u00e9cessaires \u00e0 la cr\u00e9ation d\u2019un fichier Ekahau.  Ces fichiers seront modifi\u00e9s ult\u00e9rieurement pour contenir les informations du mod\u00e8le Revit. Le reste des fichiers JSON qui composent le fichier  final Ekahau sera cr\u00e9\u00e9 plus tard, au cours de l\u2019ex\u00e9cution du code.</p>"},{"location":"docs/#copydirectorystring-sourcedir-string-destdir","title":"CopyDirectory(string sourceDir, string destDir)","text":"<ul> <li>Param\u00e8tres: (string) le chemin du r\u00e9pertoire \u00e0 copier, (string) le chemin du r\u00e9pertoire copi\u00e9</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode CopyDirectory(string sourceDir, string destDir) cr\u00e9e une copie du r\u00e9pertoire pass\u00e9 en param\u00e8tre ainsi que de tous les fichiers qu\u2019il contient,  vers l\u2019emplacement \u00e9galement pass\u00e9 en param\u00e8tre.</p>"},{"location":"docs/#getters","title":"Getters","text":"<p>La classe Getters  permet d\u2019obtenir l\u2019ID correspondant \u00e0 un type de mur Ekahau sp\u00e9cifique.</p>"},{"location":"docs/#getekahaunamefromwalldatastring-revitname-string-categoryfilter-null","title":"GetEkahauNameFromWallData(string revitName, string categoryFilter = null)","text":"<ul> <li>Param\u00e8tres: (string) le nom d\u2019un type de mur Revit, (string) la cat\u00e9gorie du mur {\"walls\", \"Doors\", \"Windows\"}</li> <li>Return: (string) Le nom d\u2019un type de mur Ekahau</li> </ul> <p>L\u2019\u00e9quivalence entre les murs Revit et Ekahau se r\u00e9alise via un fichier JSON contenant trois cat\u00e9gories : {\"walls\", \"Doors\", \"Windows\"}. Chaque cat\u00e9gorie contient le nom Revit de chaque \u00e9l\u00e9ment disponible dans le mod\u00e8le Revit ainsi que le nom du type de mur correspondant dans Ekahau. La m\u00e9thode GetEkahauNameFromWallData(string revitName, string categoryFilter = null) re\u00e7oit le nom d\u2019un \u00e9l\u00e9ment Revit et sa cat\u00e9gorie,  effectue une recherche dans le fichier wall_data.json et renvoie le nom du mur correspondant dans Ekahau.</p>"},{"location":"docs/#getwallidstring-revitwallname-string-walltypesjson","title":"GetWallId(string revitWallName, string wallTypesJson)","text":"<ul> <li>Param\u00e8tres: (string) le nom d\u2019un type de mur Revit, (string) le contenu d\u2019un fichier JSON au format string</li> <li>Return: (string) l\u2019ID du mur Ekahau correspondant</li> </ul> <p>La m\u00e9thode GetWallId(string revitWallName, string wallTypesJson) re\u00e7oit le nom d\u2019un type de mur Revit, effectue une recherche par expression r\u00e9guli\u00e8re  dans le fichier JSON au format cha\u00eene (string) et renvoie l\u2019ID du mur Ekahau correspondant.</p>"},{"location":"docs/#getwindowidstring-revitname-string-walltypesjson","title":"GetWindowId(string revitName, string wallTypesJson)","text":"<ul> <li>Param\u00e8tres: (string) le nom d\u2019un type de fen\u00eatre Revit, (string) le contenu d\u2019un fichier JSON au format string</li> <li>Return: (string) l\u2019ID du mur Ekahau correspondant</li> </ul> <p>La m\u00e9thode GetWallId(string revitWallName, string wallTypesJson) re\u00e7oit le nom d\u2019un type de fen\u00eatre Revit, effectue une recherche par expression r\u00e9guli\u00e8re  dans le fichier JSON au format cha\u00eene (string) et renvoie l\u2019ID du mur Ekahau correspondant.</p>"},{"location":"docs/#getdooridstring-revitname-string-walltypesjson","title":"GetDoorId(string revitName, string wallTypesJson)","text":"<ul> <li>Param\u00e8tres: (string) le nom d\u2019un type de porte Revit, (string) le contenu d\u2019un fichier JSON au format string</li> <li>Return: (string) l\u2019ID du mur Ekahau correspondant</li> </ul> <p>La m\u00e9thode GetWallId(string revitWallName, string wallTypesJson) re\u00e7oit le nom d\u2019un type de porte Revit, effectue une recherche par expression r\u00e9guli\u00e8re  dans le fichier JSON au format cha\u00eene (string) et renvoie l\u2019ID du mur Ekahau correspondant.</p>"},{"location":"docs/#idgenerator","title":"IDGenerator","text":"<p>La classe IDGenerator assigne de nouveaux ID dans les fichiers JSON de base qui constitueront le fichier final Ekahau.</p>"},{"location":"docs/#generateidinjsonfilesstring-destdir","title":"GenerateIDInJsonFiles(string destDir)","text":"<ul> <li>Param\u00e8tres: (string) le chemin du r\u00e9pertoire contenant les fichiers JSON qui constitueront le fichier Ekahau</li> <li>Return: Result</li> </ul> <p>Les objets contenus dans les fichiers JSON d'Ekahau poss\u00e8dent un champ \"id\" qui permet de les identifier.  Il s'agit d'une valeur GUID diff\u00e9rente pour chaque nouveau fichier. Pour g\u00e9n\u00e9rer le fichier final Ekahau,  le plugin part d\u2019une s\u00e9rie de fichiers JSON communs \u00e0 tous les fichiers Ekahau, mais dont les champs \"id\" sont vides.  La m\u00e9thode GenerateIDInJsonFiles(string destDir) permet de parcourir ces fichiers de base et de g\u00e9n\u00e9rer un nouveau GUID  dans le champ \"id\" pour chacun de ces fichiers.</p>"},{"location":"docs/#idreferencefiller","title":"IDReferenceFiller","text":"<p>La classe IDReferenceFiller permet de cr\u00e9er les r\u00e9f\u00e9rences d\u2019ID entre les diff\u00e9rents fichiers JSON qui constitueront le fichier Ekahau.</p>"},{"location":"docs/#completejsonreferencesstring-destdir-string-basename","title":"CompleteJsonReferences(string destDir, string baseName)","text":"<ul> <li>Param\u00e8tres: (string) le chemin du r\u00e9pertoire contenant les fichiers JSON, (string) le nom du fichier Ekahau</li> <li>Return: Result</li> </ul> <p>Pour identifier les objets contenus dans les fichiers JSON d'Ekahau, on utilise leur champ \"id\". Par exemple, chaque \"floor\" dans Ekahau,  qui repr\u00e9sente une \"view\" dans Revit, poss\u00e8de une image de fond. Il est donc n\u00e9cessaire, pour repr\u00e9senter correctement les \u00e9tages,  de g\u00e9n\u00e9rer correctement les r\u00e9f\u00e9rences entre les ID des fichiers floorPlans.json, images.json et le nom des images export\u00e9es depuis Revit.  La m\u00e9thode CompleteJsonReferences(string destDir, string baseName) se charge de cr\u00e9er ces r\u00e9f\u00e9rences, et de remplir les champs vides  restants tels que le nom du fichier, la date de cr\u00e9ation, etc.</p>"},{"location":"docs/#imageexporter","title":"ImageExporter","text":"<p>La classe ImageExporter exporte une image pour chaque vue s\u00e9lectionn\u00e9e du mod\u00e8le Revit et cr\u00e9e un fichier JSON auxiliaire contenant  les m\u00e9tadonn\u00e9es des images export\u00e9es.</p>"},{"location":"docs/#createviewimagesandreportexternalcommanddata-commanddata-string-outputdir-listelementid-selectedviewids","title":"CreateViewImagesAndReport(ExternalCommandData commandData, string outputDir, List&lt;ElementId&gt; selectedViewIds)","text":"<ul> <li>Param\u00e8tres: (ExternalCommandData) le mod\u00e8le Revit, (string) Le chemin du r\u00e9pertoire contenant les fichiers auxiliaires,                (List&lt;ElementId&gt;) la liste des \"Views\" s\u00e9lectionn\u00e9es</li> <li>Return: null</li> </ul> <p>La m\u00e9thode CreateViewImagesAndReport(ExternalCommandData commandData, string outputDir, List&lt;ElementId&gt; selectedViewIds) exporte  une image pour chaque vue s\u00e9lectionn\u00e9e, la stocke dans le chemin pass\u00e9 en param\u00e8tre, et cr\u00e9e au m\u00eame emplacement  un fichier JSON contenant les m\u00e9tadonn\u00e9es des images.</p>"},{"location":"docs/#imagejsonfilecreator","title":"ImageJsonFileCreator","text":"<p>La classe ImageJsonFileCreator cr\u00e9e le fichier JSON Ekahau images.json \u00e0 partir des images export\u00e9es depuis Revit,  compl\u00e8te les r\u00e9f\u00e9rences dans le fichier Ekahau floorPlans.json et d\u00e9finit l\u2019\u00e9chelle du mod\u00e8le Ekahau.</p>"},{"location":"docs/#formatimagesandcreatejsonfilestring-destdir","title":"FormatImagesAndCreateJsonFile(string destDir)","text":"<ul> <li>Param\u00e8tres: (string) le chemin du r\u00e9pertoire contenant les fichiers JSON pour le fichier Ekahau</li> <li>Return: Result</li> </ul> <p>Les images de fond (maps) dans les fichiers Ekahau doivent avoir un nom sp\u00e9cifique : image-&lt;id&gt;.  La m\u00e9thode FormatImagesAndCreateJsonFile(string destDir) prend les images export\u00e9es depuis Revit et cr\u00e9e une copie dans le  r\u00e9pertoire contenant les autres fichiers JSON n\u00e9cessaires, puis renomme les images en image-&lt;id&gt;.  Cette m\u00e9thode utilise le fichier auxiliaire imageData.json pour compl\u00e9ter les informations manquantes pour chaque  \u00e9tage (view) dans le fichier Ekahau floorPlans.json et d\u00e9finit dans ce fichier l\u2019\u00e9chelle de chaque \u00e9tage du mod\u00e8le Ekahau</p>"},{"location":"docs/#getmetersperunitstring-imagename-string-directorypath-jarray-viewinfo","title":"GetMetersPerUnit(string imageName, string directoryPath, JArray viewInfo)","text":"<ul> <li>Param\u00e8tres: (string) Le nom de l\u2019image export\u00e9e, (string) le chemin des fichiers auxiliaires, (JArray) les m\u00e9tadonn\u00e9es des images</li> <li>Return: (double) l\u2019\u00e9chelle du mod\u00e8le Ekahau en m\u00e8tres par pixel</li> </ul> <p>La m\u00e9thode GetMetersPerUnit(string imageName, string directoryPath, JArray viewInfo) utilise le chemin des fichiers auxiliaires pour  lire le fichier elements_{viewName}.json et obtenir les informations du premier mur qu\u2019elle trouve.  Elle r\u00e9cup\u00e8re \u00e9galement les informations de l\u2019image export\u00e9e correspondant au nom de l\u2019image pass\u00e9 en param\u00e8tre.  Apr\u00e8s avoir recoup\u00e9 toutes ces informations, elle effectue les calculs n\u00e9cessaires pour d\u00e9terminer l\u2019\u00e9chelle de chaque \u00e9tage dans Ekahau. Pour une explication plus d\u00e9taill\u00e9e de ce processus, consulter la section \u00ab D\u00e9finir l\u2019\u00e9chelle dans Ekahau \u00bb</p>"},{"location":"docs/#modeldataexporter","title":"ModelDataExporter","text":"<p>La classe ModelDataExporter g\u00e9n\u00e8re tous les fichiers auxiliaires n\u00e9cessaires au traitement des informations contenues dans le mod\u00e8le Revit.  Dans un premier temps, la classe cr\u00e9e un fichier JSON pour chaque vue s\u00e9lectionn\u00e9e, contenant les informations de tous les murs  et ouvertures (openings) de la vue correspondante. Ensuite, elle divise les murs en sections afin de g\u00e9n\u00e9rer l\u2019espace  n\u00e9cessaire pour les portes, fen\u00eatres et autres ouvertures, car les informations fournies par l\u2019API de Revit ne tiennent pas compte de ces ouvertures.  Elle cr\u00e9e alors un fichier JSON contenant les segments de mur pour chaque vue. Enfin, elle exporte une image pour chaque vue s\u00e9lectionn\u00e9e et g\u00e9n\u00e8re un fichier auxiliaire contenant les m\u00e9tadonn\u00e9es des images export\u00e9es.</p>"},{"location":"docs/#exportmodeldataexternalcommanddata-commanddata","title":"ExportModelData(ExternalCommandData commandData)","text":"<ul> <li>Param\u00e8tres: (ExternalCommandData) le mod\u00e8le Revit</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode ExportModelData(ExternalCommandData commandData) r\u00e9cup\u00e8re la liste des murs, des portes, des fen\u00eatres et des ouvertures g\u00e9n\u00e9rales.  Ensuite, elle d\u00e9termine quelles portes, fen\u00eatres et ouvertures sont associ\u00e9es \u00e0 chaque mur et extrait les informations pertinentes de chaque  mur et de chaque \u00e9l\u00e9ment, telles que le point d\u2019origine, le point final, la position, les dimensions, etc. Elle cr\u00e9e ensuite une liste d\u2019objets o\u00f9 chaque instance repr\u00e9sente un mur, et chaque mur contient une liste de ses ouvertures correspondantes.</p> <p>Ensuite, elle proc\u00e8de \u00e0 la division des murs en sections et cr\u00e9e un fichier JSON contenant les informations mises \u00e0 jour pour chaque vue.  Finalement, elle exporte une image pour chaque vue s\u00e9lectionn\u00e9e et g\u00e9n\u00e8re un fichier JSON auxiliaire contenant les m\u00e9tadonn\u00e9es des images</p>"},{"location":"docs/#pointandsegment","title":"PointAndSegment","text":"<p>La classe PointAndSegment cr\u00e9e un point ou un segment de mur avec la structure et le format sp\u00e9cifiques, puis les ajoute directement  aux fichiers JSON Ekahau correspondants.</p>"},{"location":"docs/#makewallpointstring-id-string-floorplanid-double-x-double-y","title":"MakeWallPoint(string id, string floorPlanId, double x, double y)","text":"<ul> <li>Param\u00e8tres: (string) l\u2019ID du point, (string) l\u2019ID du floor correspondant, (double) la coordonn\u00e9e en x du point, (double) la coordonn\u00e9e en y du point</li> <li>Return: (string) l'objet du point au format string</li> </ul> <p>La m\u00e9thode MakeWallPoint(string id, string floorPlanId, double x, double y) cr\u00e9e un objet contenant les informations d\u2019un point avec  la structure requise pour \u00eatre utilis\u00e9 dans le fichier Ekahau et le retourne au format string.</p>"},{"location":"docs/#makewallsegmentstring-idstart-string-idend-string-walltypeid","title":"MakeWallSegment(string idStart, string idEnd, string wallTypeId)","text":"<ul> <li>Param\u00e8tres: (string) l\u2019ID du point initial du segment, (string) l\u2019ID du point final du segment, (string) l\u2019ID du type de mur correspondant</li> <li>Return: (string) l'objet du segment de mur au format string</li> </ul> <p>La m\u00e9thode MakeWallSegment(string idStart, string idEnd, string wallTypeId) cr\u00e9e un objet contenant les informations d\u2019un segment de mur  avec la structure requise pour \u00eatre utilis\u00e9 dans le fichier Ekahau et le retourne au format string.</p>"},{"location":"docs/#segmentslistcreator","title":"SegmentsListCreator","text":"<p>La classe SegmentsListCreator parcourt la liste des murs et trace tous les segments de mur correspondants \u00e0 chaque mur. Pour chaque segment, elle cr\u00e9e les points  de d\u00e9part et d\u2019arriv\u00e9e dans le fichier JSON Ekahau correspondant, puis elle cr\u00e9e le segment de mur dans ce m\u00eame fichier JSON Ekahau en faisant  r\u00e9f\u00e9rence aux identifiants des points pr\u00e9alablement d\u00e9finis.</p> <p>Si une distance suffisamment courte existe entre deux segments, une connexion est cr\u00e9\u00e9e entre eux. Si une distance suffisamment petite existe  entre les extr\u00e9mit\u00e9s des murs, une connexion est \u00e9galement cr\u00e9\u00e9e entre ces extr\u00e9mit\u00e9s.</p>"},{"location":"docs/#fillsegmentslistjtoken-elementsjson-string-floorplanid-funcdouble-double-convertx-funcdouble-double-converty-string-path-liststring-wallpointslist-liststring-wallsegmentslist","title":"FillSegmentsList(JToken elementsJson, string floorPlanId, Func&lt;double, double&gt; convertX, Func&lt;double, double&gt; convertY, string path, List&lt;string&gt; wallPointsList, List&lt;string&gt; wallSegmentsList)","text":"<ul> <li>Param\u00e8tres: (JToken) l'objet qui contient tous les murs et les segments, (string) l\u2019ID de l\u2019\u00e9tage,  (Func&lt;double, double&gt;) fonction qui convertit la composante x de pieds en pixels,  (Func&lt;double, double&gt;) fonction qui convertit la composante y de pieds en pixels, (string) le chemin du r\u00e9pertoire des fichiers JSON,  (List&lt;string&gt;) la liste des points au format string, (List&lt;string&gt;) la liste des segments au string</li> <li>Return: null</li> </ul> <p>La m\u00e9thode FillSegmentsList(JToken elementsJson, string floorPlanId, Func&lt;double, double&gt; convertX, Func&lt;double, double&gt; convertY, string path,  List&lt;string&gt; wallPointsList, List&lt;string&gt; wallSegmentsList) \u00ab trace \u00bb les segments de mur dans le fichier Ekahau. Pour chaque segment,  elle ajoute les points de d\u00e9part et d\u2019arriv\u00e9e dans la liste correspondante en respectant le format Ekahau. Imm\u00e9diatement apr\u00e8s, elle ajoute le segment \u00e0  la liste correspondante en faisant r\u00e9f\u00e9rence aux identifiants des points pr\u00e9c\u00e9demment ajout\u00e9s. Si possible, elle cr\u00e9e des connexions entre  les segments et entre les extr\u00e9mit\u00e9s des murs, pour cela :</p> <p>Le code cr\u00e9e une liste auxiliaire de points qui stockera la position et l\u2019identifiant des extr\u00e9mit\u00e9s des murs.</p> <p>Si le mur contient un seul segment, cela signifie que le mur n\u2019a pas d\u2019ouvertures. Dans ce cas, le code cherche dans la liste auxiliaire  deux points situ\u00e9s \u00e0 moins d\u2019un pouce en utilisant le th\u00e9or\u00e8me de Pythagore. S\u2019il en trouve un ou les deux, le code utilise l\u2019identifiant  de ces points pour g\u00e9n\u00e9rer le segment.</p> <p>Si le mur contient plus d\u2019un segment et si le code d\u00e9tecte qu'il est en train de \u00ab tracer \u00bb un segment interm\u00e9diaire,  il calcule la distance entre le point final du segment pr\u00e9c\u00e9dent et le point initial du segment actuel. Si cette distance est inf\u00e9rieure \u00e0 un pouce,  il utilise l\u2019identifiant du point final du segment pr\u00e9c\u00e9dent au lieu d\u2019en cr\u00e9er un nouveau.</p> <p>Si le code d\u00e9tecte qu\u2019il est en train de \u00ab tracer \u00bb le premier segment, alors le point initial de ce segment correspond au d\u00e9but du mur.  Dans ce cas, le code cherche un point proche pour \u00e9tablir la connexion.</p> <p>Si le code d\u00e9tecte qu\u2019il est en train de \u00ab tracer \u00bb le dernier segment, alors le point final de ce segment correspond \u00e0 la fin du mur. Dans ce cas, le code cherche un point proche pour \u00e9tablir la connexion.</p>"},{"location":"docs/#calculatedistancedouble-x1-double-y1-double-x2-double-y2","title":"CalculateDistance(double x1, double y1, double x2, double y2)","text":"<ul> <li>Param\u00e8tres: (double) coordonn\u00e9e x du premier point, (double) coordonn\u00e9e y du premier point, (double) coordonn\u00e9e x du deuxi\u00e8me point, (double) coordonn\u00e9e y du deuxi\u00e8me point</li> <li>Return: (double) distance entre les points</li> </ul> <p>La m\u00e9thode CalculateDistance(double x1, double y1, double x2, double y2) calcule la distance entre deux points en utilisant le th\u00e9or\u00e8me de Pythagore.</p>"},{"location":"docs/#temporaryfilescollector","title":"TemporaryFilesCollector","text":"<p>La classe TemporaryFilesCollector supprime les fichiers temporaires.</p>"},{"location":"docs/#deletetemporaryfiles","title":"DeleteTemporaryFiles()","text":"<ul> <li>Param\u00e8tres: null</li> <li>Return: null</li> </ul> <p>La m\u00e9thode DeleteTemporaryFiles() supprime le dossier temporaire contenant tous les fichiers auxiliaires ainsi que tous les fichiers qu\u2019il contient.</p>"},{"location":"docs/#wallsinserter","title":"WallsInserter","text":"<p>La classe WallsInserter cr\u00e9e le fichier JSON Ekahau qui contiendra la liste des points n\u00e9cessaires pour d\u00e9finir les murs dans le mod\u00e8le Ekahau,  ainsi que le fichier JSON Ekahau qui contiendra la liste des murs. </p>"},{"location":"docs/#insertwallandopeningsinekahaufiledocument-doc","title":"InsertWallAndOpeningsInEkahauFile(Document doc)","text":"<ul> <li>Param\u00e8tres: (Document) le mod\u00e8le Revit</li> <li>Return: Result</li> </ul> <p>La m\u00e9thode InsertWallAndOpeningsInEkahauFile(Document doc) charge les fichiers JSON n\u00e9cessaires pour d\u00e9terminer la position correcte de chaque  point initial et final de chaque mur dans le mod\u00e8le Ekahau. Elle cr\u00e9e une liste contenant tous les points n\u00e9cessaires et une autre liste  contenant les murs du mod\u00e8le. Deux fonctions sont d\u00e9finies : l\u2019une pour convertir la coordonn\u00e9e X d\u2019un point de pieds en pixels, l\u2019autre  pour convertir la coordonn\u00e9e Y. Pour plus d\u2019informations sur ces deux fonctions, consultez la section \u00ab Conversion des coordonn\u00e9es de Revit vers Ekahau \u00bb.</p> <p>La m\u00e9thode remplit les listes avec les points et les murs obtenus, puis cr\u00e9e finalement les fichiers JSON Ekahau wallPoints.json et wallSegments.json  dans le r\u00e9pertoire contenant le reste des fichiers JSON Ekahau</p>"},{"location":"docs/#wallsplitter","title":"WallSplitter","text":"<p>Lors de l\u2019obtention de la liste des murs et des ouvertures via l\u2019API de Revit, la seule relation qu\u2019une ouverture conserve avec le mur dans  lequel elle est encastr\u00e9e est son identifiant (ID). Par cons\u00e9quent, m\u00eame si un mur dans Revit contient une ouverture, l\u2019API retourne uniquement  les points de d\u00e9but et de fin du mur, sans prendre en compte la position ni les dimensions des ouvertures qu\u2019il peut contenir.</p> <p>La classe WallSplitter cr\u00e9e les ouvertures n\u00e9cessaires dans le mur en le divisant en sections, afin d\u2019obtenir une repr\u00e9sentation graphique  du projet plus r\u00e9aliste.</p>"},{"location":"docs/#splitwallbyopeningstring-inputfilename-string-outputfilename","title":"SplitWallByOpening(string inputFileName, string outputFileName)","text":"<ul> <li>Param\u00e8tres: (string) le fichier JSON qui contient les informations des murs et de leurs ouvertures,  (string) le fichier JSON qui contiendra les informations originales ainsi que les sections cr\u00e9\u00e9es</li> <li>Return: null</li> </ul> <p>La m\u00e9thode SplitWallByOpening(string inputFileName, string outputFileName) r\u00e9cup\u00e8re la liste des murs et de leurs ouvertures \u00e0 partir  du fichier JSON pass\u00e9 en param\u00e8tre. Elle divise chaque mur en sections en fonction de la liste d\u2019ouvertures qu\u2019il contient,  puis ajoute ces sections \u00e0 la liste des ouvertures du mur.</p> <p>Les segments sont ajout\u00e9s \u00e0 la liste des ouvertures, car une ouverture peut repr\u00e9senter un vide, une porte ou une fen\u00eatre, et aussi bien les portes,  les fen\u00eatres que les segments de mur doivent \u00eatre \u00ab trac\u00e9s \u00bb dans le mod\u00e8le Ekahau. Une autre partie du code d\u00e9terminera s\u2019il s\u2019agit d\u2019une porte,  d\u2019une fen\u00eatre, d\u2019un segment ou d\u2019un vide.</p> <p>Finalement, la m\u00e9thode trie les ouvertures par position de mani\u00e8re ascendante, ainsi que tous les points de d\u00e9but et de fin de chaque ouverture et du mur concern\u00e9.</p>"},{"location":"docs/#lengthbetweenpointspoint-p1-point-p2","title":"LengthBetweenPoints(Point p1, Point p2)","text":"<ul> <li>Param\u00e8tres: (Point) le premier point, (Point) le deuxi\u00e8me point</li> <li>Return: (double) la distance entre les points</li> </ul> <p>La m\u00e9thode LengthBetweenPoints(Point p1, Point p2) calcule la distance entre deux points en utilisant le th\u00e9or\u00e8me de Pythagore.</p>"},{"location":"docs/#centerofelementopeningdata-element","title":"CenterOfElement(OpeningData element)","text":"<ul> <li>Param\u00e8tres: (OpeningData) une ouverture au format objet</li> <li>Return: (Point) le point central de l\u2019ouverture</li> </ul> <p>La m\u00e9thode CenterOfElement(OpeningData element) retourne le point central d\u2019une ouverture.</p>"},{"location":"docs/#iscenterinsidewallwalldata-wall-point-center","title":"IsCenterInsideWall(WallData wall, Point center)","text":"<ul> <li>Param\u00e8tres: (WallData) un mur au format objet, (Point) un point</li> <li>Return: (bool) vrai si le point se trouve entre les extr\u00e9mit\u00e9s du mur</li> </ul> <p>La m\u00e9thode IsCenterInsideWall(WallData wall, Point center) d\u00e9termine si un point se trouve entre les extr\u00e9mit\u00e9s d\u2019un mur.</p>"},{"location":"docs/#recursivewallsplitwalldata-wall-listopeningdata-openings-listwalldata-results","title":"RecursiveWallSplit(WallData wall, List&lt;OpeningData&gt; openings, List&lt;WallData&gt; results)","text":"<ul> <li>Param\u00e8tres: (WallData) un mur au format objet, (List&lt;OpeningData&gt;) la liste des ouvertures, (List&lt;WallData&gt;) la liste qui contiendra les segments</li> <li>Return: null</li> </ul> <p>La m\u00e9thode RecursiveWallSplit(WallData wall, List&lt;OpeningData&gt; openings, List&lt;WallData&gt; results) est une m\u00e9thode r\u00e9cursive  qui divise un mur en sections selon la liste des ouvertures, en suivant ces \u00e9tapes :</p> <p>Cas de base : Si la liste des ouvertures est vide, enregistrez le mur dans la liste des r\u00e9sultats.  Cas r\u00e9cursif : Si la liste des ouvertures n\u2019est pas vide, prenez la premi\u00e8re ouverture et divisez le mur en deux segments. Le premier  segment va d\u2019une extr\u00e9mit\u00e9 du mur \u00e0 une extr\u00e9mit\u00e9 de l\u2019ouverture, le second segment va de l\u2019autre extr\u00e9mit\u00e9 du mur \u00e0 l\u2019autre extr\u00e9mit\u00e9 de l\u2019ouverture. Pour chaque segment, cr\u00e9ez une liste d\u2019ouvertures et conservez celles dont le centre se trouve \u00e0 l\u2019int\u00e9rieur des limites du segment. Ensuite, appelez la fonction r\u00e9cursivement avec ces segments et les listes d\u2019ouvertures correspondantes.</p> <p>Pour plus d\u2019informations sur ce processus, consultez la section \u00ab \u00bb.</p>"},{"location":"docs/#windowdoordimensions","title":"WindowDoorDimensions","text":"<p>La classe WindowDoorDimensions est responsable d'obtenir les dimensions et la position spatiale d'\u00e9l\u00e9ments de type fen\u00eatre ou porte (FamilyInstance) dans un mod\u00e8le Revit.</p>"},{"location":"docs/#getwindowdoordimensionsfamilyinstance-inst-double-wallx1-double-wally1-double-wallz1-double-wallx2-double-wally2-double-wallz2","title":"GetWindowDoorDimensions(FamilyInstance inst, double wallX1, double wallY1, double wallZ1, double wallX2, double wallY2, double wallZ2)","text":"<ul> <li>Param\u00e8tres : (FamilyInstance) instance de famille {fen\u00eatre, porte}, (double) coordonn\u00e9e X du premier extr\u00e9mit\u00e9 du mur,  (double) coordonn\u00e9e Y du premier extr\u00e9mit\u00e9 du mur, (double) coordonn\u00e9e Z du premier extr\u00e9mit\u00e9 du mur, (double) coordonn\u00e9e X du second extr\u00e9mit\u00e9 du mur,  (double) coordonn\u00e9e Y du second extr\u00e9mit\u00e9 du mur, (double) coordonn\u00e9e Z du second extr\u00e9mit\u00e9 du mur </li> <li>Return: (object) objet contenant les informations de l\u2019ouverture</li> </ul> <p>La m\u00e9thode GetWindowDoorDimensions(FamilyInstance inst, double wallX1, double wallY1, double wallZ1, double wallX2, double wallY2, double wallZ2)  obtient les dimensions (largeur et hauteur) et la position spatiale (centre, points de d\u00e9part et de fin) d'une instance de fen\u00eatre ou porte  \u00e0 l'int\u00e9rieur d'un mur d\u00e9fini par deux points.</p> <p>La m\u00e9thode r\u00e9cup\u00e8re les dimensions de mani\u00e8re progressive : Tente d'obtenir les param\u00e8tres \"Width\" et \"Height\" directement depuis l'instance. Si non disponibles, tente de r\u00e9cup\u00e9rer ces param\u00e8tres depuis le symbole familial (FamilySymbol) en utilisant les param\u00e8tres BuiltIn. Si toujours indisponibles, calcule les dimensions \u00e0 partir de la g\u00e9om\u00e9trie de l'instance.</p> <p>Ensuite, elle calcule la position centrale de l'\u00e9l\u00e9ment dans l'espace, en ajustant les coordonn\u00e9es X et Y pour correspondre au mur si n\u00e9cessaire. Elle calcule \u00e9galement deux points (start_point et end_point) perpendiculaires \u00e0 l'orientation de l'\u00e9l\u00e9ment qui repr\u00e9sentent l'extension  en plan en tenant compte de la largeur.</p> <p>Finalement, elle retourne un objet anonyme contenant les informations pertinentes : type, id, nom, position, dimensions et points extr\u00eames.</p>"},{"location":"docs/#interaction-entre-les-classes-et-leurs-methodes","title":"Interaction entre les classes et leurs m\u00e9thodes","text":"<p>Le diagramme suivant illustre l\u2019interaction entre les diff\u00e9rentes m\u00e9thodes du code. Plus pr\u00e9cis\u00e9ment, il montre le flux de travail g\u00e9n\u00e9ral en  indiquant \u00e0 quelle m\u00e9thode chaque m\u00e9thode fait appel. Dans le diagramme, chaque m\u00e9thode appelle celle qui se trouve \u00e0 l\u2019int\u00e9rieur de sa propre figure. Le num\u00e9ro \u00e0 l\u2019int\u00e9rieur des m\u00e9thodes principales indique l\u2019ordre dans lequel elles sont appel\u00e9es par la m\u00e9thode Export.Execute().</p> <p></p>"},{"location":"docs/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <p>Erreurs courantes et solutions</p> <p>\u00c0 venir</p> </li> <li> <p>Questions fr\u00e9quentes (FAQ)</p> <p>\u00c0 venir</p> </li> </ul>"},{"location":"evaluation/","title":"\u00c9valuation","text":""},{"location":"evaluation/#plan-de-test","title":"Plan de test","text":"<ul> <li>Tests unitaires des fonctions principales du code</li> </ul>"},{"location":"evaluation/#criteres-devaluation","title":"Crit\u00e8res d'\u00e9valuation","text":"<p>L\u2019\u00e9valuation du plugin sera r\u00e9alis\u00e9e manuellement sur des mod\u00e8les Revit disponibles sur le site officiel Autodesk. Pour garantir le bon fonctionnement du plugin, d\u2019autres sources que le site officiel Autodesk peuvent \u00e9galement \u00eatre consult\u00e9es.</p>"},{"location":"evaluation/#liste-des-fichiers","title":"Liste des fichiers","text":"Mod\u00e8le Origine Statut rac_basic_sample_project.rvt Site officiel Autodesk Non conforme rac_advanced_sample_project.rvt Site officiel Autodesk Non conforme"},{"location":"evaluation/#analyse-des-resultats","title":"Analyse des r\u00e9sultats","text":"<ul> <li>Discuter des r\u00e9sultats obtenus lors des tests.</li> </ul>"},{"location":"evaluation/#open-issues","title":"Open Issues","text":""},{"location":"evaluation/#problemes-ouverts-par-exigence","title":"Probl\u00e8mes ouverts par Exigence","text":"<p>Exigence - Le fichier Ekahau doit contenir tous les murs, portes et fen\u00eatres du mod\u00e8le Revit, ou uniquement ceux situ\u00e9s \u00e0 l\u2019int\u00e9rieur de la zone d\u00e9limit\u00e9e par l\u2019utilisateur. </p> Probl\u00e8m - Le code ne d\u00e9tecte pas toutes les portes, par exemple Slider_Door Probl\u00e8m - Il reste \u00e0 effectuer des tests sur des mod\u00e8les contenant des portes dans des murs inclin\u00e9s.  Probl\u00e8m - La repr\u00e9sentation graphique de certains murs dans Revit appara\u00eet incompl\u00e8te en raison de la superposition d\u2019autres \u00e9l\u00e9ments tels que les murs-rideaux (Curtain Walls) ou les garde-corps (Rails), tandis que l\u2019API ne refl\u00e8te pas ce changement. Il est n\u00e9cessaire de trouver un moyen d\u2019exporter correctement le mur sectionn\u00e9.  Probl\u00e8m - Pour le moment, le code obtient les dimensions des portes et fen\u00eatres de diff\u00e9rentes mani\u00e8res selon le type d\u2019\u00e9l\u00e9ment. Id\u00e9alement, il faudrait disposer d\u2019une m\u00e9thode unique et unifi\u00e9e pour le faire.   <p>Exigence - Le fichier g\u00e9n\u00e9r\u00e9 doit contenir un b\u00e2timent structur\u00e9 par \u00e9tages, refl\u00e9tant fid\u00e8lement l\u2019organisation du mod\u00e8le Revit. </p> Probl\u00e8m - V\u00e9rifier que les \u00e9tages sont ordonn\u00e9s correctement (du premier \u00e9tage au dernier, de mani\u00e8re ascendante) dans Ekahau.  Probl\u00e8m - Pour le moment, la hauteur des \u00e9tages ainsi que l\u2019\u00e9paisseur des planchers et des plafonds dans le fichier Ekahau export\u00e9 ne correspondent pas au mod\u00e8le Revit.   <p>Exigence - Le plugin doit \u00eatre facile \u00e0 utiliser par des ing\u00e9nieurs ne poss\u00e9dant pas de connaissances approfondies en programmation. </p> Probl\u00e8m - Il n\u2019existe actuellement aucun moyen d\u2019annuler l\u2019exportation du mod\u00e8le une fois le processus lanc\u00e9.   <p>Exigence - L\u2019exportation doit \u00eatre rapide, afin de ne pas perturber le travail quotidien des utilisateurs. </p> Probl\u00e8m - Le code g\u00e9n\u00e8re de nombreux fichiers temporaires qui ne sont pas supprim\u00e9s apr\u00e8s la fin du processus d\u2019exportation.       La cr\u00e9ation et la manipulation de ces fichiers ralentissent l\u2019ex\u00e9cution du code.       Il est donc n\u00e9cessaire d\u2019\u00e9viter de g\u00e9n\u00e9rer ces fichiers, et s\u2019ils sont indispensables, de les supprimer \u00e0 la fin du processus."},{"location":"references/","title":"R\u00e9f\u00e9rences","text":"<ul> <li> <p>Lister les ouvrages, articles et ressources acad\u00e9miques consult\u00e9s.</p> </li> <li> <p>Inclure des liens vers des sites web, outils ou technologies utilis\u00e9s.</p> </li> </ul>"},{"location":"resources/","title":"Resources","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Decision}\n    B --&gt;|Yes| C[Continue]\n    B --&gt;|No| D[Stop]\n</code></pre> <pre><code>pie title Which animals do you prefer as pets?\n    \"Dogs\" : 386\n    \"Cats\" : 85\n    \"Rabbits\" : 53\n    \"Hamsters\" : 101\n</code></pre>"},{"location":"resources/#why-its-useful-in-ift3150","title":"Why it's useful in IFT3150:","text":"<p>For computer science projects, visualizing algorithms, data flow, or system architecture is key. Mermaid lets students easily include diagrams without needing external images.</p>"},{"location":"resources/#pymdown-extensions","title":"\u2705 <code>pymdown-extensions</code>","text":"<p>This is a collection of enhanced Markdown extensions, mostly used with Material for MkDocs. It enables:</p> <ul> <li>Better code highlighting with <code>superfences</code></li> <li>Tabs in Markdown (<code>tabbed</code>)</li> <li>Collapsible sections (<code>details</code>)</li> <li>Checkboxes for task lists (<code>tasklist</code>)</li> <li>Emoji support</li> <li>Keyboard key notation (<code>keys</code>)</li> <li>And many more UX-friendly features</li> </ul>"},{"location":"resources/#example-use-cases","title":"\ud83d\udd27 Example use cases:","text":"Python <pre><code>def hello():\n    print(\"Hello, world!\")\n</code></pre> Java <pre><code>public class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world!\");\n    }\n}\n</code></pre> <p>Note</p> <p>This is an important note for the reader.</p>"},{"location":"results/","title":"R\u00e9sultats","text":""},{"location":"results/#fonctionnalites","title":"Fonctionnalit\u00e9s","text":"<ul> <li>D\u00e9crire les fonctionnalit\u00e9s impl\u00e9ment\u00e9es.</li> </ul>"},{"location":"results/#demonstration","title":"D\u00e9monstration","text":"<ul> <li>Inclure des captures d'\u00e9cran ou des d\u00e9monstrations du syst\u00e8me.</li> </ul>"},{"location":"results/#bilan","title":"Bilan","text":"<ul> <li>\u00c9valuer la r\u00e9alisation des objectifs initiaux.</li> </ul>"},{"location":"suivi/","title":"Suivi de projet","text":""},{"location":"suivi/#semaine-1","title":"Semaine 1","text":""},{"location":"suivi/#prise-de-connaissance-du-projet","title":"Prise de connaissance du projet","text":"<ul> <li>D\u00e9finition de la liste des logiciels, langages et outils n\u00e9cessaires au projet</li> <li>D\u00e9finition de l\u2019objectif et de la port\u00e9e du projet</li> </ul>"},{"location":"suivi/#semaine-2","title":"Semaine 2","text":""},{"location":"suivi/#phase-dexploration-des-logiciels","title":"Phase d\u2019exploration des logiciels","text":"<ul> <li>Exploration de l\u2019API de Revit<ul> <li>Analyse de la documentation officielle et des exemples fournis.</li> <li>D\u00e9couverte des classes et m\u00e9thodes principales.</li> <li>Exp\u00e9rimentation des m\u00e9canismes de filtrage et de s\u00e9lection d\u2019\u00e9l\u00e9ments dans un mod\u00e8le.</li> <li>Compr\u00e9hension des flux de donn\u00e9es et des \u00e9v\u00e9nements que l\u2019API permet de g\u00e9rer.</li> </ul> </li> <li>Exploration de Ekahau<ul> <li>Analyse approfondie pour comprendre l\u2019organisation et le format des fichiers Ekahau.</li> </ul> </li> <li>Premier prototype (na\u00eff)</li> </ul> <p>Difficult\u00e9s rencontr\u00e9es</p> <ul> <li>Ekahau ne propose pas d\u2019interface API permettant la manipulation directe de ses mod\u00e8les.</li> </ul>"},{"location":"suivi/#semaine-3","title":"Semaine 3","text":""},{"location":"suivi/#modelisation-uml","title":"Mod\u00e9lisation UML","text":"<ul> <li>Cr\u00e9ation de mod\u00e8les UML distincts pour Revit et Ekahau dans le but de d\u00e9finir clairement le flux de travail et les interactions entre les deux syst\u00e8mes.</li> </ul>"},{"location":"suivi/#semaine-4","title":"Semaine 4","text":""},{"location":"suivi/#description-formelle-du-projet","title":"Description formelle du projet","text":"<p>Apr\u00e8s s\u2019\u00eatre r\u00e9uni avec l\u2019\u00e9quipe de travail de BPA et s\u2019\u00eatre familiaris\u00e9 avec les outils Revit et Ekahau,  il est d\u00e9sormais possible de d\u00e9finir formellement le projet et sa port\u00e9e. Cela permet \u00e9galement de mieux  comprendre les exigences du client ainsi que de d\u00e9terminer la m\u00e9thodologie \u00e0 suivre pour le d\u00e9veloppement du plugin.</p>"},{"location":"suivi/#semaine-5","title":"Semaine 5","text":""},{"location":"suivi/#premier-prototype","title":"Premier prototype","text":"<ul> <li>Le code correspondant au premier prototype est ajout\u00e9 au d\u00e9p\u00f4t du projet.</li> </ul>"},{"location":"suivi/#semaine-6","title":"Semaine 6","text":""},{"location":"suivi/#demonstration-du-premier-prototype","title":"D\u00e9monstration du premier prototype","text":"<ul> <li>La d\u00e9monstration du premier prototype est r\u00e9alis\u00e9e lors d'une r\u00e9union avec le client.</li> <li>Les fonctionnalit\u00e9s finales que le code devra inclure pour la partie Export sont d\u00e9finies.</li> </ul>"},{"location":"suivi/#semaine-7","title":"Semaine 7","text":""},{"location":"suivi/#automatic-scaling-functionality-is-added","title":"Automatic scaling functionality is added.","text":"<p>For Ekahau to perform an analysis whose results accurately reflect reality, it is necessary to set the real-world scale within the Ekahau model.  This is done by drawing a line anywhere on the model (map) and entering the actual length of that line.  For example, if there is a wall that is 3 meters long, you draw a line from one end of the wall to the other and enter the value 3 as the line\u2019s length.</p> <p>Instead of doing that, the code has been modified to randomly select a wall and perform the necessary calculations to determine the model\u2019s real-world scale.  These calculations are possible because Revit uses feet as its internal unit of measurement, making it feasible to deduce the real scale of the Revit model  from any element it contains.</p>"},{"location":"suivi/#semaine-8","title":"Semaine 8","text":""},{"location":"suivi/#an-option-is-added-to-exclude-the-stair-area-in-the-ekahau-model","title":"An option is added to exclude the stair area in the Ekahau model.","text":"<p>During one of the meetings held with the team responsible for the Plugin on BPA\u2019s side, we were informed that it is common to exclude certain elements  from the Revit model when performing the analysis in Ekahau\u2014specifically elevators and staircases. To achieve this automatically,  the code has been modified to add an option in the view selection screen that allows the user to specify whether they want to add an exclusion  zone corresponding to the stair area or include the stair area in the analysis. In the latter case, the code does not add any exclusion zone.</p>"},{"location":"suivi/#semaine-9","title":"Semaine 9","text":""},{"location":"suivi/#a-method-for-mapping-revit-walls-to-ekahau-walls-is-added","title":"A method for mapping Revit walls to Ekahau walls is added","text":"<p>One of the main challenges in developing the plugin is finding a way to establish a correspondence between Revit wall types and Ekahau wall types.  After conducting online research, it was concluded that there is no analytical method to calculate a wall\u2019s attenuation level. Instead,  the most common approach is to physically measure these values and extrapolate them to other types of walls that share similar characteristics.</p> <p>For this reason, the correspondence between wall types in the two programs has been designed to be defined manually by the user.  A JSON file has been created containing all the available wall, door, and window types from Revit, and each wall type includes  a field where the corresponding Ekahau wall type can be specified. The values in this file can be edited through the Revit GUI  to make it easier for the user to update them.</p>"},{"location":"suivi/#semaine-10","title":"Semaine 10","text":""},{"location":"suivi/#the-crop-area-is-determined-automatically","title":"The crop area is determined automatically","text":"<p>To export the model as a BMP image, Revit uses the crop region as the model boundaries; everything inside the crop region will be exported within the image.  After several attempts, it has been determined that there are actually at least two types of crop regions: one for the geometry (the elements contained in the model)  and one for annotations (dimensions, texts, etc.). In cases where the annotation crop region does not include all annotations inside it, the final model in Ekahau  will have scaling and alignment problems between the wall segments of the model and the background image.</p> <p>To avoid these problems, the code has been modified so that the crop area includes all annotations within it automatically, without the user needing to worry about it.</p>"},{"location":"suivi/#semaine-11","title":"Semaine 11","text":""},{"location":"suivi/#release-of-version-net-80","title":"Release of version NET 8.0","text":"<p>Starting with the 2025 version, Revit uses .NET version 8.0. Since the BPA development team uses different versions of Revit \u2014 including versions  before and after 2025 \u2014 it is necessary to develop a .NET 8.0 version of the plugin. This week, the code using .NET 8.0 with the same functionalities as the  .NET 4.8 version is released</p>"},{"location":"suivi/#semaine-12","title":"Semaine 12","text":""},{"location":"suivi/#semaine-13","title":"Semaine 13","text":""}]}